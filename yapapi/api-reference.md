<a name="yapapi"></a>
# yapapi

Golem Python API.

<a name="yapapi.get_version"></a>
#### get\_version

```python
get_version() -> str
```

**Returns**:

the version of the yapapi library package

<a name="yapapi.windows_event_loop_fix"></a>
#### windows\_event\_loop\_fix

```python
windows_event_loop_fix()
```

Set up asyncio to use ProactorEventLoop implementation for new event loops on Windows.

This work-around is only needed for Python 3.6 and 3.7.
With Python 3.8, `ProactorEventLoop` is already the default on Windows.

<a name="yapapi.log"></a>
# yapapi.log

Utilities for logging computation events via the standard `logging` module.

Functions in this module fall into two categories:

* Functions that convert computation events generated by the `Executor.submit`
method to calls to the standard Python `logging` module, using the loggers
in the "yapapi" namespace (e.g. `logging.getLogger("yapapi.executor")`).
These functions should be passed as `event_consumer` arguments to `Executor()`.

* Functions that perform configuration of the `logging` module itself.
Since logging configuration is in general a responsibility of the code that
uses `yapapi` as a library, we only provide the `enable_default_logger`
function in this category, that enables logging to stderr with level `logging.INFO`
and, optionally, to a given file with level `logging.DEBUG`.


Functions for handling events
-----------------------------

Several functions from this module can be passed as `event_consumer` callback to
`yapapi.Executor()`.

For detailed, human-readable output use the `log_event` function:
```python
    Executor(..., event_consumer=yapapi.log.log_event)
```
For even more detailed, machine-readable output use `log_event_repr`:
```python
    Executor(..., event_consumer=yapapi.log.log_event_repr)
```
For summarized, human-readable output use `log_summary()`:
```python
    Executor(..., event_consumer=yapapi.log.log_summary())
```
Summary output can be combined with a detailed one by passing the detailed logger
as an argument to `log_summary`:
```python
    Executor(
        ...
        event_consumer=yapapi.log.log_summary(yapapi.log.log_event_repr)
    )
```

<a name="yapapi.log.enable_default_logger"></a>
#### enable\_default\_logger

```python
enable_default_logger(format_: str = "[%(asctime)s %(levelname)s %(name)s] %(message)s", log_file: Optional[str] = None, debug_activity_api: bool = False, debug_market_api: bool = False, debug_payment_api: bool = False)
```

Enable the default logger that logs messages to stderr with level `INFO`.

If `log_file` is specified, the logger with output messages with level `DEBUG` to
the given file.

<a name="yapapi.log.log_event"></a>
#### log\_event

```python
log_event(event: events.Event) -> None
```

Log `event` with a human-readable description.

<a name="yapapi.log.log_event_repr"></a>
#### log\_event\_repr

```python
log_event_repr(event: events.Event) -> None
```

Log the result of calling `repr(event)`.

<a name="yapapi.log.SummaryLogger"></a>
## SummaryLogger Objects

```python
class SummaryLogger()
```

Aggregates information from computation events to provide a high-level summary.

The logger's `log()` method can be used as `event_consumer` callback
to `Executor()`. It will aggregate the events generated by `Executor.submit()`
and output some summary information.

The optional `wrapped_emitter` argument can be used for chaining event
emitters: each event logged with `log()` is first passed to
`wrapped_emitter`.

For example, with the following setup, each event emitted by `executor`
will be logged by `log_event_repr`, and additionally, certain events
will cause summary messages to be logged.
```python
    detailed_logger = log_event_repr
    summary_logger = SummaryLogger(wrapped_emitter=detailed_logger).log
    executor = Executor(..., event_consumer=summary_logger)
```

<a name="yapapi.log.SummaryLogger.__init__"></a>
#### \_\_init\_\_

```python
 | __init__(wrapped_emitter: Optional[Callable[[events.Event], None]] = None)
```

Create a SummaryLogger.

<a name="yapapi.log.SummaryLogger.log"></a>
#### log

```python
 | log(event: events.Event) -> None
```

Register an event.

<a name="yapapi.log.log_summary"></a>
#### log\_summary

```python
log_summary(wrapped_emitter: Optional[Callable[[events.Event], None]] = None)
```

Output a summary of computation.

This is a utility function that creates a `SummaryLogger` instance
wrapping an optional `wrapped_emitter` and returns its `log` method.

See the documentation of `SummaryLogger` for more information.

<a name="yapapi.props"></a>
# yapapi.props

<a name="yapapi.props.NodeInfo"></a>
## NodeInfo Objects

```python
@dataclass
class NodeInfo(Model)
```

Properties describing the information regarding the node.

<a name="yapapi.props.NodeInfo.name"></a>
#### name

human-readable name of the Golem node

<a name="yapapi.props.NodeInfo.subnet_tag"></a>
#### subnet\_tag

the name of the subnet within which the Demands and Offers are matched

<a name="yapapi.props.Activity"></a>
## Activity Objects

```python
@dataclass()
class Activity(Model)
```

Activity-related Properties

<a name="yapapi.props.Activity.cost_cap"></a>
#### cost\_cap

Sets a Hard cap on total cost of the Activity (regardless of the usage vector or
pricing function). The Provider is entitled to 'kill' an Activity which exceeds the
capped cost amount indicated by Requestor.

<a name="yapapi.props.Activity.cost_warning"></a>
#### cost\_warning

Sets a Soft cap on total cost of the Activity (regardless of the usage vector or
pricing function). When the cost_warning amount is reached for the Activity,
the Provider is expected to send a Debit Note to the Requestor, indicating
the current amount due

<a name="yapapi.props.Activity.timeout_secs"></a>
#### timeout\_secs

A timeout value for batch computation (eg. used for container-based batch
processes). This property allows to set the timeout to be applied by the Provider
when running a batch computation: the Requestor expects the Activity to take
no longer than the specified timeout value - which implies that
eg. the golem.usage.duration_sec counter shall not exceed the specified
timeout value.

<a name="yapapi.props.Activity.multi_activity"></a>
#### multi\_activity

Whether client supports multi_activity (executing more than one activity per agreement).

<a name="yapapi.props.builder"></a>
# yapapi.props.builder

<a name="yapapi.props.builder.DemandBuilder"></a>
## DemandBuilder Objects

```python
class DemandBuilder()
```

Builds a dictionary of properties and constraints from high-level models.

The dictionary represents a Demand object, which is later matched by the new Golem's
market implementation against Offers coming from providers to find those providers
who can satisfy the requestor's demand.

example usage:

```python
>>> import yapapi
>>> from yapapi import properties as yp
>>> from yapapi.props.builder import DemandBuilder
>>> from datetime import datetime, timezone
>>> builder = DemandBuilder()
>>> builder.add(yp.NodeInfo(name="a node", subnet_tag="testnet"))
>>> builder.add(yp.Activity(expiration=datetime.now(timezone.utc)))
>>> builder.__repr__
>>> print(builder)
{'properties':
    {'golem.node.id.name': 'a node',
     'golem.node.debug.subnet': 'testnet',
     'golem.srv.comp.expiration': 1601655628772},
 'constraints': []}
```

<a name="yapapi.props.builder.DemandBuilder.properties"></a>
#### properties

```python
 | @property
 | properties() -> dict
```

List of properties for this demand.

<a name="yapapi.props.builder.DemandBuilder.constraints"></a>
#### constraints

```python
 | @property
 | constraints() -> str
```

List of constraints for this demand.

<a name="yapapi.props.builder.DemandBuilder.ensure"></a>
#### ensure

```python
 | ensure(constraint: str)
```

Add a constraint to the demand definition.

<a name="yapapi.props.builder.DemandBuilder.add"></a>
#### add

```python
 | add(m: Model)
```

Add properties from the specified model to this demand definition.

<a name="yapapi.props.builder.DemandBuilder.subscribe"></a>
#### subscribe

```python
 | async subscribe(market: Market) -> Subscription
```

Create a Demand on the market and subscribe to Offers that will match that Demand.

<a name="yapapi.props.com"></a>
# yapapi.props.com

Payment-related properties.

<a name="yapapi.props.inf"></a>
# yapapi.props.inf

Infrastructural properties.

<a name="yapapi.props.base"></a>
# yapapi.props.base

<a name="yapapi.props.base.InvalidPropertiesError"></a>
## InvalidPropertiesError Objects

```python
class InvalidPropertiesError(Exception)
```

Raised by `Model.from_properties(cls, properties)` when given invalid `properties`.

<a name="yapapi.props.base.Model"></a>
## Model Objects

```python
class Model(abc.ABC)
```

Base class from which all property models inherit.

Provides helper methods to load the property model data from a dictionary and
to get a mapping of all the keys available in the given model.

<a name="yapapi.props.base.Model.from_properties"></a>
#### from\_properties

```python
 | @classmethod
 | from_properties(cls: Type[ME], props: Props) -> ME
```

Initialize the model from a dictionary representation.

When provided with a dictionary of properties, it will find the matching keys
within it and fill the model fields with the values from the dictionary.

It ignores non-matching keys - i.e. doesn't require filtering of the properties'
dictionary before the model is fed with the data. Thus, several models can be
initialized from the same dictionary and all models will only load their own data.

<a name="yapapi.props.base.Model.keys"></a>
#### keys

```python
 | @classmethod
 | keys(cls)
```

**Returns**:

a mapping between the model's field names and the property keys

example:
```python
>>> import dataclasses
>>> import typing
>>> from yapapi.properties.base import Model
>>> @dataclasses.dataclass
... class NodeInfo(Model):
...     name: typing.Optional[str] = \
...     dataclasses.field(default=None, metadata={"key": "golem.node.id.name"})
...
>>> NodeInfo.keys().name
'golem.node.id.name'
```

<a name="yapapi.storage"></a>
# yapapi.storage

Storage models.

<a name="yapapi.storage.OutputStorageProvider"></a>
## OutputStorageProvider Objects

```python
class OutputStorageProvider(abc.ABC)
```

<a name="yapapi.storage.OutputStorageProvider.new_destination"></a>
#### new\_destination

```python
 | @abc.abstractmethod
 | async new_destination(destination_file: Optional[PathLike] = None) -> Destination
```

Creates slot for receiving file.

Parameters
----------
destination_file:
    Optional hint where received data should be placed.

<a name="yapapi.storage.webdav"></a>
# yapapi.storage.webdav

<a name="yapapi.storage.gftp"></a>
# yapapi.storage.gftp

Golem File Transfer Storage Provider

<a name="yapapi.storage.gftp.PubLink"></a>
## PubLink Objects

```python
class PubLink(TypedDict)
```

GFTP linking information.

<a name="yapapi.storage.gftp.PubLink.file"></a>
#### file

file on local filesystem.

<a name="yapapi.storage.gftp.PubLink.url"></a>
#### url

GFTP url as which local files is exposed.

<a name="yapapi.storage.gftp.GftpDriver"></a>
## GftpDriver Objects

```python
class GftpDriver(Protocol)
```

Golem FTP service API.

<a name="yapapi.storage.gftp.GftpDriver.version"></a>
#### version

```python
 | async version() -> str
```

Gets driver version.

<a name="yapapi.storage.gftp.GftpDriver.publish"></a>
#### publish

```python
 | async publish(*, files: List[str]) -> List[PubLink]
```

Exposes local file as GFTP url.

`files`
:   local files to be exposed

<a name="yapapi.storage.gftp.GftpDriver.close"></a>
#### close

```python
 | async close(*, urls: List[str]) -> CommandStatus
```

Stops exposing GFTP urls created by [publish(files=[..])](`publish`).

<a name="yapapi.storage.gftp.GftpDriver.receive"></a>
#### receive

```python
 | async receive(*, output_file: str) -> PubLink
```

Creates GFTP url for receiving file.

:  `output_file` -

<a name="yapapi.storage.gftp.GftpDriver.shutdown"></a>
#### shutdown

```python
 | async shutdown() -> CommandStatus
```

Stops GFTP service.

After shutdown all generated urls will be unavailable.

<a name="yapapi._cli"></a>
# yapapi.\_cli

<a name="yapapi._cli.run"></a>
# yapapi.\_cli.run

<a name="yapapi._cli.market"></a>
# yapapi.\_cli.market

<a name="yapapi._cli.market.Demand"></a>
## Demand Objects

```python
class Demand()
```

Offer subscription management.

<a name="yapapi._cli.market.Demand.list"></a>
#### list

```python
 | @async_run
 | async list(only_expired: bool = False)
```

Lists all active demands

<a name="yapapi._cli.market.Demand.clear"></a>
#### clear

```python
 | @async_run
 | async clear(only_expired: bool = False)
```

Removes demands.

By default removes all demands.

**Arguments**:

- `only_expired`: removes only expired demands.

<a name="yapapi._cli.payment"></a>
# yapapi.\_cli.payment

<a name="yapapi._cli.payment.Allocation"></a>
## Allocation Objects

```python
class Allocation()
```

Payment allocation management.

<a name="yapapi._cli.payment.Allocation.list"></a>
#### list

```python
 | @async_run
 | async list(details: bool = False)
```

Lists current active payment allocation

<a name="yapapi._cli.payment.Allocation.clear"></a>
#### clear

```python
 | @async_run
 | async clear()
```

Removes all active payment allocations

<a name="yapapi._cli.payment.Invoices"></a>
## Invoices Objects

```python
class Invoices()
```

Invoice management.

<a name="yapapi._cli.payment.Invoices.accept"></a>
#### accept

```python
 | @async_run
 | async accept(allocation_id: str, invoice_id: str)
```

Accepts given `invoice_id` with `allocation_id`

**Arguments**:

- `allocation_id`: Allocation from which invoice will be paid. see
`allocation list`.
- `invoice_id`: Invoice identifier.

<a name="yapapi._cli.payment.Invoices.list"></a>
#### list

```python
 | @async_run
 | async list(by_status: Optional[str] = None)
```

Lists all invoices.

<a name="yapapi.executor"></a>
# yapapi.executor

An implementation of the new Golem's task executor.

<a name="yapapi.executor.DEBIT_NOTE_MIN_TIMEOUT"></a>
#### DEBIT\_NOTE\_MIN\_TIMEOUT

Shortest debit note acceptance timeout the requestor will accept.

<a name="yapapi.executor.CFG_INVOICE_TIMEOUT"></a>
#### CFG\_INVOICE\_TIMEOUT

Time to receive invoice from provider after tasks ended.

<a name="yapapi.executor.NoPaymentAccountError"></a>
## NoPaymentAccountError Objects

```python
class NoPaymentAccountError(Exception)
```

The error raised if no payment account for the required driver/network is available.

<a name="yapapi.executor.NoPaymentAccountError.required_driver"></a>
#### required\_driver

Payment driver required for the account.

<a name="yapapi.executor.NoPaymentAccountError.required_network"></a>
#### required\_network

Network required for the account.

<a name="yapapi.executor.Executor"></a>
## Executor Objects

```python
class Executor(AsyncContextManager)
```

Task executor.

Used to run tasks using the specified application package within providers' execution units.

<a name="yapapi.executor.Executor.__init__"></a>
#### \_\_init\_\_

```python
 | __init__(*, package: Package, max_workers: int = 5, timeout: timedelta = timedelta(minutes=5), budget: Union[float, Decimal], strategy: MarketStrategy = LeastExpensiveLinearPayuMS(), subnet_tag: Optional[str] = None, driver: Optional[str] = None, network: Optional[str] = None, event_consumer: Optional[Callable[[Event], None]] = None)
```

Create a new executor.

**Arguments**:

- `package`: a package common for all tasks; vm.repo() function may be
used to return package from a repository
- `max_workers`: maximum number of workers doing the computation
- `timeout`: timeout for the whole computation
- `budget`: maximum budget for payments
- `strategy`: market strategy used to select providers from the market
(e.g. LeastExpensiveLinearPayuMS or DummyMS)
- `subnet_tag`: use only providers in the subnet with the subnet_tag name
- `driver`: name of the payment driver to use or `None` to use the default driver;
only payment platforms with the specified driver will be used
- `network`: name of the network to use or `None` to use the default network;
only payment platforms with the specified network will be used
- `event_consumer`: a callable that processes events related to the
computation; by default it is a function that logs all events

<a name="yapapi.executor.Executor.submit"></a>
#### submit

```python
 | async submit(worker: Callable[[WorkContext, AsyncIterator[Task[D, R]]], AsyncGenerator[Work, None]], data: Iterable[Task[D, R]]) -> AsyncIterator[Task[D, R]]
```

Submit a computation to be executed on providers.

**Arguments**:

- `worker`: a callable that takes a WorkContext object and a list o tasks,
adds commands to the context object and yields committed commands
- `data`: an iterator of Task objects to be computed on providers

**Returns**:

yields computation progress events

<a name="yapapi.executor._smartq"></a>
# yapapi.executor.\_smartq

YAPAPI internal module. This is not a part of the public API. It can change at any time.

<a name="yapapi.executor._smartq.SmartQueue"></a>
## SmartQueue Objects

```python
class SmartQueue(Generic[Item],  object)
```

<a name="yapapi.executor._smartq.SmartQueue.has_new_items"></a>
#### has\_new\_items

```python
 | has_new_items() -> bool
```

Check whether this queue has any items that were not retrieved by any consumer yet.

<a name="yapapi.executor._smartq.SmartQueue.has_unassigned_items"></a>
#### has\_unassigned\_items

```python
 | has_unassigned_items() -> bool
```

Check whether this queue has any unassigned items.

An item is _unassigned_ if it's new (hasn't been retrieved yet by any consumer)
or it has been rescheduled and is not in progress.

A queue has unassigned items iff `get()` will immediately return some item,
without waiting for an item that is currently "in progress" to be rescheduled.

<a name="yapapi.executor.task"></a>
# yapapi.executor.task

<a name="yapapi.executor.task.Task"></a>
## Task Objects

```python
class Task(Generic[TaskData, TaskResult])
```

One computation unit.

Represents one computation unit that will be run on the provider
(e.g. rendering of one frame of an animation).

<a name="yapapi.executor.task.Task.__init__"></a>
#### \_\_init\_\_

```python
 | __init__(data: TaskData)
```

Create a new Task object.

**Arguments**:

- `data`: contains information needed to prepare command list for the provider

<a name="yapapi.executor.task.Task.running_time"></a>
#### running\_time

```python
 | @property
 | running_time() -> Optional[timedelta]
```

Return the running time of the task (if in progress) or time it took to complete it.

<a name="yapapi.executor.task.Task.accept_result"></a>
#### accept\_result

```python
 | accept_result(result: Optional[TaskResult] = None) -> None
```

Accept the result of this task.

Must be called when the result is correct to mark this task
as completed.

**Arguments**:

- `result`: task computation result (optional)

**Returns**:

None

<a name="yapapi.executor.task.Task.reject_result"></a>
#### reject\_result

```python
 | reject_result(reason: Optional[str] = None, retry: bool = False) -> None
```

Reject the result of this task.

Must be called when the result is not correct to indicate
that the task should be retried.

**Arguments**:

- `reason`: task rejection description (optional)

**Returns**:

None

<a name="yapapi.executor.agreements_pool"></a>
# yapapi.executor.agreements\_pool

<a name="yapapi.executor.agreements_pool.BufferedAgreement"></a>
## BufferedAgreement Objects

```python
@dataclass
class BufferedAgreement()
```

Confirmed agreement with additional local metadata

<a name="yapapi.executor.agreements_pool.AgreementsPool"></a>
## AgreementsPool Objects

```python
class AgreementsPool()
```

Manages proposals and agreements pool

<a name="yapapi.executor.agreements_pool.AgreementsPool.cycle"></a>
#### cycle

```python
 | async cycle()
```

Performs cyclic tasks.

Should be called regularly.

<a name="yapapi.executor.agreements_pool.AgreementsPool.add_proposal"></a>
#### add\_proposal

```python
 | async add_proposal(score: float, proposal: OfferProposal) -> None
```

Adds providers' proposal to the pool of available proposals

<a name="yapapi.executor.agreements_pool.AgreementsPool.use_agreement"></a>
#### use\_agreement

```python
 | async use_agreement(cbk)
```

Gets an agreement and performs cbk() on it

<a name="yapapi.executor.agreements_pool.AgreementsPool.release_agreement"></a>
#### release\_agreement

```python
 | async release_agreement(agreement_id: str) -> None
```

Marks agreement as ready for reuse

<a name="yapapi.executor.agreements_pool.AgreementsPool.terminate"></a>
#### terminate

```python
 | async terminate(reason: dict) -> None
```

Terminates all agreements

<a name="yapapi.executor.agreements_pool.AgreementsPool.on_agreement_terminated"></a>
#### on\_agreement\_terminated

```python
 | async on_agreement_terminated(agr_id: str, reason: dict) -> None
```

Reacts to agreement termination event

Should be called when AgreementTerminated event is received.

<a name="yapapi.executor.events"></a>
# yapapi.executor.events

Representing events in Golem computation.

<a name="yapapi.executor.events.Event"></a>
## Event Objects

```python
@dataclass(init=False)
class Event()
```

An abstract base class for types of events emitted by `Executor.submit()`.

<a name="yapapi.executor.events.Event.extract_exc_info"></a>
#### extract\_exc\_info

```python
 | extract_exc_info() -> Tuple[Optional[ExcInfo], "Event"]
```

Extract exception information from this event.

Return the extracted exception information
and a copy of the event without the exception information.

<a name="yapapi.executor.events.HasExcInfo"></a>
## HasExcInfo Objects

```python
@dataclass(init=False)
class HasExcInfo(Event)
```

A base class for types of events that carry an optional exception info.

<a name="yapapi.executor.events.HasExcInfo.extract_exc_info"></a>
#### extract\_exc\_info

```python
 | extract_exc_info() -> Tuple[Optional[ExcInfo], "Event"]
```

Return the `exc_info` field and a copy of this event with the field set to `None`.

<a name="yapapi.executor.events.ComputationFinished"></a>
## ComputationFinished Objects

```python
@dataclass
class ComputationFinished(HasExcInfo)
```

Indicates successful completion if `exc_info` is `None` and a failure otherwise.

<a name="yapapi.executor.events.WorkerFinished"></a>
## WorkerFinished Objects

```python
@dataclass
class WorkerFinished(HasExcInfo,  AgreementEvent)
```

Indicates successful completion if `exc_info` is `None` and a failure otherwise.

<a name="yapapi.executor.events.ShutdownFinished"></a>
## ShutdownFinished Objects

```python
@dataclass
class ShutdownFinished(HasExcInfo)
```

Indicates the completion of Executor shutdown sequence

<a name="yapapi.executor.strategy"></a>
# yapapi.executor.strategy

Implementation of strategies for choosing offers from market.

<a name="yapapi.executor.strategy.MarketStrategy"></a>
## MarketStrategy Objects

```python
class MarketStrategy(abc.ABC)
```

Abstract market strategy.

<a name="yapapi.executor.strategy.MarketStrategy.decorate_demand"></a>
#### decorate\_demand

```python
 | async decorate_demand(demand: DemandBuilder) -> None
```

Optionally add relevant constraints to a Demand.

<a name="yapapi.executor.strategy.MarketStrategy.score_offer"></a>
#### score\_offer

```python
 | async score_offer(offer: rest.market.OfferProposal) -> float
```

Score `offer`. Better offers should get higher scores.

<a name="yapapi.executor.strategy.DummyMS"></a>
## DummyMS Objects

```python
@dataclass
class DummyMS(MarketStrategy,  object)
```

A default market strategy implementation.

Its `score_offer()` method returns `SCORE_NEUTRAL` for every offer with prices
that do not exceed maximum prices specified for each counter.
For other offers, returns `SCORE_REJECTED`.

<a name="yapapi.executor.strategy.DummyMS.decorate_demand"></a>
#### decorate\_demand

```python
 | async decorate_demand(demand: DemandBuilder) -> None
```

Ensure that the offer uses `PriceModel.LINEAR` price model.

<a name="yapapi.executor.strategy.DummyMS.score_offer"></a>
#### score\_offer

```python
 | async score_offer(offer: rest.market.OfferProposal) -> float
```

Score `offer`. Returns either `SCORE_REJECTED` or `SCORE_NEUTRAL`.

<a name="yapapi.executor.strategy.LeastExpensiveLinearPayuMS"></a>
## LeastExpensiveLinearPayuMS Objects

```python
@dataclass
class LeastExpensiveLinearPayuMS(MarketStrategy,  object)
```

A strategy that scores offers according to cost for given computation time.

<a name="yapapi.executor.strategy.LeastExpensiveLinearPayuMS.decorate_demand"></a>
#### decorate\_demand

```python
 | async decorate_demand(demand: DemandBuilder) -> None
```

Ensure that the offer uses `PriceModel.LINEAR` price model.

<a name="yapapi.executor.strategy.LeastExpensiveLinearPayuMS.score_offer"></a>
#### score\_offer

```python
 | async score_offer(offer: rest.market.OfferProposal) -> float
```

Score `offer` according to cost for expected computation time.

<a name="yapapi.executor.utils"></a>
# yapapi.executor.utils

Utility functions and classes used within the `yapapi.executor` package.

<a name="yapapi.executor.utils.AsyncWrapper"></a>
## AsyncWrapper Objects

```python
class AsyncWrapper()
```

Wraps a given callable to provide asynchronous calls.

Example usage:

  with AsyncWrapper(func) as wrapper:
      wrapper.async_call("Hello", world=True)
      wrapper.async_call("Bye!")

The above code will make two asynchronous calls to `func`.
The results of the calls, if any, are discarded, so this class is
most useful for wrapping callables that return `None`.

<a name="yapapi.executor.utils.AsyncWrapper.stop"></a>
#### stop

```python
 | async stop() -> None
```

Stop the wrapper, process queued calls but do not accept any new ones.

<a name="yapapi.executor.utils.AsyncWrapper.async_call"></a>
#### async\_call

```python
 | async_call(*args, **kwargs) -> None
```

Schedule an asynchronous call to the wrapped callable.

<a name="yapapi.executor.ctx"></a>
# yapapi.executor.ctx

<a name="yapapi.executor.ctx.Work"></a>
## Work Objects

```python
class Work(abc.ABC)
```

<a name="yapapi.executor.ctx.Work.prepare"></a>
#### prepare

```python
 | async prepare()
```

A hook to be executed on requestor's end before the script is sent to the provider.

<a name="yapapi.executor.ctx.Work.register"></a>
#### register

```python
 | register(commands: CommandContainer)
```

A hook which adds the required command to the exescript.

<a name="yapapi.executor.ctx.Work.post"></a>
#### post

```python
 | async post()
```

A hook to be executed on requestor's end after the script has finished.

<a name="yapapi.executor.ctx.Work.timeout"></a>
#### timeout

```python
 | @property
 | timeout() -> Optional[timedelta]
```

Return the optional timeout set for execution of this work.

<a name="yapapi.executor.ctx._Steps"></a>
## \_Steps Objects

```python
class _Steps(Work)
```

<a name="yapapi.executor.ctx._Steps.timeout"></a>
#### timeout

```python
 | @property
 | timeout() -> Optional[timedelta]
```

Return the optional timeout set for execution of all steps.

<a name="yapapi.executor.ctx._Steps.prepare"></a>
#### prepare

```python
 | async prepare()
```

Execute the `prepare` hook for all the defined steps.

<a name="yapapi.executor.ctx._Steps.register"></a>
#### register

```python
 | register(commands: CommandContainer)
```

Execute the `register` hook for all the defined steps.

<a name="yapapi.executor.ctx._Steps.post"></a>
#### post

```python
 | async post()
```

Execute the `post` step for all the defined steps.

<a name="yapapi.executor.ctx.WorkContext"></a>
## WorkContext Objects

```python
class WorkContext()
```

An object used to schedule commands to be sent to provider.

<a name="yapapi.executor.ctx.WorkContext.id"></a>
#### id

Unique identifier for this work context.

<a name="yapapi.executor.ctx.WorkContext.provider_name"></a>
#### provider\_name

```python
 | @property
 | provider_name() -> Optional[str]
```

Return the name of the provider associated with this work context.

<a name="yapapi.executor.ctx.WorkContext.send_json"></a>
#### send\_json

```python
 | send_json(json_path: str, data: dict)
```

Schedule sending JSON data to the provider.

**Arguments**:

- `json_path`: remote (provider) path
- `data`: dictionary representing JSON data

**Returns**:

None

<a name="yapapi.executor.ctx.WorkContext.send_file"></a>
#### send\_file

```python
 | send_file(src_path: str, dst_path: str)
```

Schedule sending file to the provider.

**Arguments**:

- `src_path`: local (requestor) path
- `dst_path`: remote (provider) path

**Returns**:

None

<a name="yapapi.executor.ctx.WorkContext.run"></a>
#### run

```python
 | run(cmd: str, *args: Iterable[str], *, env: Optional[Dict[str, str]] = None)
```

Schedule running a command.

**Arguments**:

- `cmd`: command to run on the provider, e.g. /my/dir/run.sh
- `args`: command arguments, e.g. "input1.txt", "output1.txt"
- `env`: optional dictionary with environmental variables

**Returns**:

None

<a name="yapapi.executor.ctx.WorkContext.download_file"></a>
#### download\_file

```python
 | download_file(src_path: str, dst_path: str)
```

Schedule downloading remote file from the provider.

**Arguments**:

- `src_path`: remote (provider) path
- `dst_path`: local (requestor) path

**Returns**:

None

<a name="yapapi.executor.ctx.WorkContext.commit"></a>
#### commit

```python
 | commit(timeout: Optional[timedelta] = None) -> Work
```

Creates sequence of commands to be sent to provider.

**Returns**:

Work object (the latter contains
sequence commands added before calling this method)

<a name="yapapi.__main__"></a>
# yapapi.\_\_main\_\_

<a name="yapapi.rest"></a>
# yapapi.rest

Mid-level binding for Golem REST API.

Serves as a more convenient interface between the agent code and the REST API.

<a name="yapapi.rest.configuration"></a>
# yapapi.rest.configuration

<a name="yapapi.rest.configuration.Configuration"></a>
## Configuration Objects

```python
class Configuration(object)
```

REST API's setup and top-level access utility.

By default, it expects the yagna daemon to be available locally and listening on the
default port. The urls for the specific APIs are then based on this default base URL.

It requires one external argument, namely Yagna's application key, which is
used to authenticate with the daemon. The application key must be either specified
explicitly using the `app_key` argument or provided by the `YAGNA_APPKEY` environment variable.

If `YAGNA_API_URL` environment variable exists, it will be used as a base URL
for all REST API URLs. Example value: http://127.0.10.10:7500 (no trailing slash).

Other than that, the URLs of each specific REST API can be overridden
using the following environment variables:
* `YAGNA_MARKET_URL`
* `YAGNA_PAYMENT_URL`
* `YAGNA_ACTIVITY_URL`

<a name="yapapi.rest.configuration.Configuration.app_key"></a>
#### app\_key

```python
 | @property
 | app_key() -> str
```

Yagna daemon's application key used to access the REST API.

<a name="yapapi.rest.configuration.Configuration.market_url"></a>
#### market\_url

```python
 | @property
 | market_url() -> str
```

The URL of the Market REST API

<a name="yapapi.rest.configuration.Configuration.payment_url"></a>
#### payment\_url

```python
 | @property
 | payment_url() -> str
```

The URL of the Payment REST API

<a name="yapapi.rest.configuration.Configuration.activity_url"></a>
#### activity\_url

```python
 | @property
 | activity_url() -> str
```

The URL of the Activity REST API

<a name="yapapi.rest.configuration.Configuration.market"></a>
#### market

```python
 | market() -> ya_market.ApiClient
```

Return a REST client for the Market API.

<a name="yapapi.rest.configuration.Configuration.payment"></a>
#### payment

```python
 | payment() -> ya_payment.ApiClient
```

Return a REST client for the Payment API.

<a name="yapapi.rest.configuration.Configuration.activity"></a>
#### activity

```python
 | activity() -> ya_activity.ApiClient
```

Return a REST client for the Activity API.

<a name="yapapi.rest.market"></a>
# yapapi.rest.market

<a name="yapapi.rest.market.AgreementDetails"></a>
## AgreementDetails Objects

```python
class AgreementDetails(object)
```

<a name="yapapi.rest.market.AgreementDetails.View"></a>
## View Objects

```python
@dataclass
class View()
```

A certain fragment of an agreement's properties.

<a name="yapapi.rest.market.AgreementDetails.View.extract"></a>
#### extract

```python
 | extract(m: Type[_ModelType]) -> _ModelType
```

Extract properties for the given model from this view's properties.

<a name="yapapi.rest.market.AgreementDetails.provider_view"></a>
#### provider\_view

```python
 | @property
 | provider_view() -> View
```

Get the view of provider's properties in this Agreement.

<a name="yapapi.rest.market.AgreementDetails.requestor_view"></a>
#### requestor\_view

```python
 | @property
 | requestor_view() -> View
```

Get the view of requestor's properties in this Agreement.

<a name="yapapi.rest.market.Agreement"></a>
## Agreement Objects

```python
class Agreement(object)
```

Mid-level interface to the REST's Agreement model.

<a name="yapapi.rest.market.Agreement.confirm"></a>
#### confirm

```python
 | async confirm() -> bool
```

Sign and send the agreement to the provider and then wait for it to be approved.

**Returns**:

True if the agreement has been confirmed, False otherwise

<a name="yapapi.rest.market.OfferProposal"></a>
## OfferProposal Objects

```python
class OfferProposal(object)
```

Mid-level interface to handle the negotiation phase between the parties.

<a name="yapapi.rest.market.OfferProposal.reject"></a>
#### reject

```python
 | async reject(reason: Optional[str] = None)
```

Reject the Offer.

<a name="yapapi.rest.market.OfferProposal.respond"></a>
#### respond

```python
 | async respond(props: dict, constraints: str) -> str
```

Create an agreeement Proposal for a received Offer, based on our Demand.

<a name="yapapi.rest.market.OfferProposal.create_agreement"></a>
#### create\_agreement

```python
 | async create_agreement(timeout=timedelta(hours=1)) -> Agreement
```

Create an Agreement based on this Proposal.

<a name="yapapi.rest.market.Subscription"></a>
## Subscription Objects

```python
class Subscription(object)
```

Mid-level interface to REST API's Subscription model.

<a name="yapapi.rest.market.Subscription.details"></a>
#### details

```python
 | @property
 | details() -> models.Demand
```

**Returns**:

the Demand for which the Subscription has been registered.

<a name="yapapi.rest.market.Subscription.delete"></a>
#### delete

```python
 | async delete()
```

Unsubscribe this Demand from the market.

<a name="yapapi.rest.market.Subscription.events"></a>
#### events

```python
 | async events() -> AsyncIterator[OfferProposal]
```

Yield counter-proposals based on the incoming, matching Offers.

<a name="yapapi.rest.market.Market"></a>
## Market Objects

```python
class Market(object)
```

Mid-level interface to the Market REST API.

<a name="yapapi.rest.market.Market.subscribe"></a>
#### subscribe

```python
 | subscribe(props: dict, constraints: str) -> AsyncResource[Subscription]
```

Create a subscription for a demand specified by the supplied properties and constraints.

<a name="yapapi.rest.market.Market.subscriptions"></a>
#### subscriptions

```python
 | async subscriptions() -> AsyncIterator[Subscription]
```

Yield all the subscriptions that this requestor agent has on the market.

<a name="yapapi.rest.activity"></a>
# yapapi.rest.activity

<a name="yapapi.rest.activity.ActivityService"></a>
## ActivityService Objects

```python
class ActivityService(object)
```

A convenience helper to facilitate the creation of an Activity.

<a name="yapapi.rest.activity.ActivityService.new_activity"></a>
#### new\_activity

```python
 | async new_activity(agreement_id: str) -> "Activity"
```

Create an activity within bounds of the specified agreement.

**Returns**:

the object that represents the Activity
and allows to query and control its state
:rtype: Activity

<a name="yapapi.rest.activity.Activity"></a>
## Activity Objects

```python
class Activity(AsyncContextManager["Activity"])
```

Mid-level wrapper for REST's Activity endpoint

<a name="yapapi.rest.activity.Activity.state"></a>
#### state

```python
 | async state() -> yaa.ActivityState
```

Query the state of the activity.

<a name="yapapi.rest.activity.Activity.send"></a>
#### send

```python
 | async send(script: List[dict], stream: bool = False, deadline: Optional[datetime] = None)
```

Send the execution script to the provider's execution unit.

<a name="yapapi.rest.activity.Activity.__aexit__"></a>
#### \_\_aexit\_\_

```python
 | async __aexit__(exc_type, exc_val, exc_tb) -> None
```

Call DestroyActivity API operation.

<a name="yapapi.rest.activity.CommandExecutionError"></a>
## CommandExecutionError Objects

```python
class CommandExecutionError(Exception)
```

An exception that indicates that a command failed on a provider.

<a name="yapapi.rest.activity.CommandExecutionError.command"></a>
#### command

The command that failed.

<a name="yapapi.rest.activity.CommandExecutionError.message"></a>
#### message

The command's output, if any.

<a name="yapapi.rest.activity.BatchTimeoutError"></a>
## BatchTimeoutError Objects

```python
class BatchTimeoutError(Exception)
```

An exception that indicates that an execution of a batch of commands timed out.

<a name="yapapi.rest.activity.Batch"></a>
## Batch Objects

```python
class Batch(abc.ABC,  AsyncIterable[events.CommandEventContext])
```

Abstract base class for iterating over events related to a batch running on provider.

<a name="yapapi.rest.activity.Batch.seconds_left"></a>
#### seconds\_left

```python
 | seconds_left() -> float
```

Return how many seconds are left until the deadline.

<a name="yapapi.rest.activity.Batch.id"></a>
#### id

```python
 | @property
 | id()
```

Return the ID of this batch.

<a name="yapapi.rest.activity.PollingBatch"></a>
## PollingBatch Objects

```python
class PollingBatch(Batch)
```

A `Batch` implementation that polls the server repeatedly for command status.

<a name="yapapi.rest.activity.StreamingBatch"></a>
## StreamingBatch Objects

```python
class StreamingBatch(Batch)
```

A `Batch` implementation that uses event streaming to return command status.

<a name="yapapi.rest.resource"></a>
# yapapi.rest.resource

<a name="yapapi.rest.payment"></a>
# yapapi.rest.payment

<a name="yapapi.rest.payment.Allocation"></a>
## Allocation Objects

```python
@dataclass
class Allocation(_Link)
```

Payment reservation for task processing.

<a name="yapapi.rest.payment.Allocation.id"></a>
#### id

Allocation object id

<a name="yapapi.rest.payment.Allocation.amount"></a>
#### amount

Total amount allocated

<a name="yapapi.rest.payment.Allocation.payment_platform"></a>
#### payment\_platform

Payment platform, e.g. NGNT

<a name="yapapi.rest.payment.Allocation.payment_address"></a>
#### payment\_address

Payment address, e.g. 0x123...

<a name="yapapi.rest.payment.Allocation.expires"></a>
#### expires

Allocation expiration timestamp

<a name="yapapi.rest.payment.Payment"></a>
## Payment Objects

```python
class Payment(object)
```

<a name="yapapi.rest.payment.Payment.new_allocation"></a>
#### new\_allocation

```python
 | new_allocation(amount: Decimal, payment_platform: str, payment_address: str, *, expires: Optional[datetime] = None, make_deposit: bool = False) -> ResourceCtx[Allocation]
```

Creates new allocation.

- `amount`:  Allocation amount.
- `expires`: expiration timestamp. by default 30 minutes from now.
- `make_deposit`: (unimplemented).

<a name="yapapi.rest.payment.Payment.allocations"></a>
#### allocations

```python
 | async allocations() -> AsyncIterator[Allocation]
```

Lists all active allocations.

**Example**:

  
  Listing all active allocations
  
  from yapapi import rest
  
  async def list_allocations(payment_api: rest.Payment):
  async for allocation in payment_api.allocations():
- `print(f'''allocation` - {allocation.id}
  amount={allocation.amount},
  expires={allocation.expires}''')

<a name="yapapi.package"></a>
# yapapi.package

<a name="yapapi.package.PackageException"></a>
## PackageException Objects

```python
class PackageException(Exception)
```

Exception raised on any problems related to the package repository.

<a name="yapapi.package.Package"></a>
## Package Objects

```python
class Package(abc.ABC)
```

Information on task package to be used for running tasks on providers.

<a name="yapapi.package.Package.resolve_url"></a>
#### resolve\_url

```python
 | @abc.abstractmethod
 | async resolve_url() -> str
```

Return package URL.

<a name="yapapi.package.Package.decorate_demand"></a>
#### decorate\_demand

```python
 | @abc.abstractmethod
 | async decorate_demand(demand: DemandBuilder)
```

Add package information to a Demand.

<a name="yapapi.package.vm"></a>
# yapapi.package.vm

<a name="yapapi.package.vm.repo"></a>
#### repo

```python
async repo(*, image_hash: str, min_mem_gib: float = 0.5, min_storage_gib: float = 2.0) -> Package
```

Build reference to application package.

- *image_hash*: finds package by its contents hash.
- *min_mem_gib*: minimal memory required to execute application code.
- *min_storage_gib* minimal disk storage to execute tasks.

<a name="yapapi.package.vm.resolve_repo_srv"></a>
#### resolve\_repo\_srv

```python
resolve_repo_srv(repo_srv, fallback_url=_FALLBACK_REPO_URL) -> str
```

Get the url of the package repository based on its SRV record address.

**Arguments**:

- `repo_srv`: the SRV domain name
- `fallback_url`: temporary hardcoded fallback url in case there's a problem resolving SRV

**Returns**:

the url of the package repository containing the port
:raises: PackageException if no valid service could be reached

<a name="examples"></a>
# examples

<a name="examples.utils"></a>
# examples.utils

Utilities for yapapi example scripts.

