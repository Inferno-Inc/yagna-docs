---
description: Introducing log files
---

# Debugging

When developing applications on Golem, sooner or later you will get to a point where something is not working as expected. Executing commands on the provider-hosted container seems to be one of the most error-prone areas. If something is going wrong on the provider side, we need to have a tool that helps us in problem identification. When we know what are the error details it usually is much easier to correct our code and thus eliminate the bug.

## Introducing log files

The good news is that Golem high-level API supports log files. The log files contain all sorts of interesting stuff. Among others you will find there:

* Requestor &gt; Provider file transfer details
* Output streams of executing commands on the Provider: `stdout` and `stderr`
* Provider &gt; Requestor file transfer details

## How to enable logging?

The logging infrastructure in Golem's high-level API is quite universal and thus complicated, but for most of the cases using the `SummaryLogger` will do the job. 

{% hint style="info" %}
The `SummaryLogger`is an event listener that listens to all the atomic events and combines them into the more aggregated track of events that is easier to grasp by humans.
{% endhint %}

To enable logging to a file we need two things:

```python
enable_default_logger(log_file=args.log_file)
```

`enable_default_logger` enables default logger that: 

* outputs to the Requestor application's `stderr` all the log messages with the level `INFO`
* if the `log_file` is specified, outputs to the file specified all the log messages with the level `INFO` and `DEBUG`

Then in the `Executor`we need to:

```python
    async with Executor(
        ...
        event_consumer=log_summary(log_event_repr),
        ...
    ) as executor:
```

The `log_summary` creates `SummaryLogger` instance that is passed as event consumer to the Executor we are creating.

## Let's have an error

Let's look at the code of yacat that is part of the Golem high-level Python API repository. All the code that enables logging is already there. We just need to use `--log-file` command-line switch.

{% embed url="https://github.com/golemfactory/yapapi/blob/master/examples/yacat/yacat.py" %}

In line 24 we are generating the body of `keyspace.sh` script to be executed on the provider:

```python
def write_keyspace_check_script(mask):
    with open("keyspace.sh", "w") as f:
        f.write(f"hashcat --keyspace -a 3 {mask} -m 400 > /golem/work/keyspace.txt")
```

Now we are simulating a typo in the code. Instead of

`hashcat --keyspace -a 3 {mask} -m 400 > /golem/work/keyspace.txt`

...let's have the following code

`hashcat --keeyspace -a 3 {mask} -m 400 > /golem/work/keyspace.txt`

so just additional `e` that have not been noticed. A typical developer day.

Save the file and run the yacat with some example mask and hash:

{% tabs %}
{% tab title="Unix  / MacOS" %}
```python
python3 yacat.py '?a?a?a' '$P$5ZDzPE45CLLhEx/72qt3NehVzwN2Ry/' --log-file log.txt
```
{% endtab %}

{% tab title="Windows" %}
```
python yacat.py ?a?a?a $P$5ZDzPE45CLLhEx/72qt3NehVzwN2Ry/ --log-file log.txt
```
{% endtab %}
{% endtabs %}

## Reading the log file

And now let's try to track the effect of our typo in the content of `log.txt` - the file that has been generated by yacat because of using `--log-file log.txt`.

First, let's find the first `ctx.run` command track. We can do it by searching the log.txt file \(from the top of the file, for example by hitting Ctrl-F in our favorite file viewer\) in search of 

```python
command={'run'
```

This way we can find log entry that looks like this:

```python
[2021-01-22 15:20:16,273 DEBUG yapapi.events] 
CommandStarted(agr_id='b39318a4c682010ea9be37201b8f428fad81b28cfe949ca11cca9912a465d34c', 
task_id='1', cmd_idx=3, command={'run': {'entry_point': '/bin/sh', 'args': 
['/golem/work/keyspace.sh'], 'capture': {'stdout': {'stream': {}}, 'stderr': {'stream': {}}}}})
```

now below that, there are the log entries we were looking for:

```python
[2021-01-22 15:20:16,383 DEBUG yapapi.events] 
CommandStdErr(agr_id='b39318a4c682010ea9be37201b8f428fad81b28cfe949ca11cca9912a465d34c', 
task_id='1', cmd_idx=3, 
output="hashcat: unrecognized option '--keeyspace'\n\x1b[31mInvalid argument specified.\x1b[0m\n\n")
[2021-01-22 15:20:16,385 DEBUG yapapi.events] 
CommandExecuted(agr_id='b39318a4c682010ea9be37201b8f428fad81b28cfe949ca11cca9912a465d34c', 
task_id='1', cmd_idx=3, command={'run': {'entry_point': '/bin/sh', 'args': 
('/golem/work/keyspace.sh',), 'capture': {'stdout': {'stream': {}}, 'stderr': {'stream': {}}}}}, 
success=False, message='ExeScript command exited with code 255')
```

There are two parts of those log entries that are most important:

`hashcat: unrecognized option '--keeyspace'\n\x1b[31mInvalid argument specified.\x1b[0m\n\n`

This is `stderr` message generated by running `hashcat` binary. It seems that the `hashcat` does not recognize the `--keeyspace` parameter. This is the error we simulated. 

{% hint style="info" %}
Congratulations! You just tracked the bug by analyzing the requestor log file.
{% endhint %}

The other interesting stuff here is

`ExeScript command exited with code 255`

By the above, we know that the effect of this `ctx.run` resulted with exit code having value of `255`. The value of `255` has been returned by `hashcat` on exit. If there is any additional information in the command exit code, we can track it here.

{% hint style="danger" %}
The `255` value, we have in the log file here is generated by equivalent of POSIX `exit(-1)` executed on the `hashcat` termination. The `-1` was converted to `unsigned int` and become`255`.
{% endhint %}

## Fixing the error

Now fix the `write_keyspace_check_script` to the correct form that is:

```python
def write_keyspace_check_script(mask):
    with open("keyspace.sh", "w") as f:
        f.write(f"hashcat --keyspace -a 3 {mask} -m 400 > /golem/work/keyspace.txt")
```

After saving the corrected `yacat.py` file and executing with the same command as above:

{% tabs %}
{% tab title="Unix  / MacOS" %}
```python
python3 yacat.py '?a?a?a' '$P$5ZDzPE45CLLhEx/72qt3NehVzwN2Ry/' --log-file log.txt
```
{% endtab %}

{% tab title="Windows" %}
```
python yacat.py ?a?a?a $P$5ZDzPE45CLLhEx/72qt3NehVzwN2Ry/ --log-file log.txt
```
{% endtab %}
{% endtabs %}

the problematic log fragment we analyzed above, becomes the following:

```python
[2021-01-22 16:22:17,217 DEBUG yapapi.events] 
CommandStarted(agr_id='bf8c484e362af417cbf5fc440281debd5c5cf772b433f53e0ecb90b4faac55f4', 
task_id='1', cmd_idx=3, command={'run': {'entry_point': '/bin/sh', 'args': 
['/golem/work/keyspace.sh'], 'capture': {'stdout': {'stream': {}}, 'stderr': {'stream': {}}}}})
[2021-01-22 16:22:18,303 DEBUG yapapi.events] 
CommandExecuted(agr_id='bf8c484e362af417cbf5fc440281debd5c5cf772b433f53e0ecb90b4faac55f4', 
task_id='1', cmd_idx=3, command={'run': {'entry_point': '/bin/sh', 'args': ('/golem/work/keyspace.sh',), 
'capture': {'stdout': {'stream': {}}, 'stderr': {'stream': {}}}}}, success=True, message=None)
```

As you see we have `success=True` with means that the `ctx.run` execution was successful.

{% hint style="info" %}
Congratulations! Error in the code has been corrected.
{% endhint %}

## Log files - what else is there?

In the log file there are all the information you are f 

## Docker exec - an alternative approach 



